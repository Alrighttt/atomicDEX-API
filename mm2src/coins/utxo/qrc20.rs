use super::*;
use crate::eth::{u256_to_big_decimal, wei_from_big_decimal, ERC20_CONTRACT, PAYMENT_STATE_SENT,
                 PAYMENT_STATE_UNINITIALIZED, SWAP_CONTRACT};
use crate::utxo::rpc_clients::UtxoRpcClientOps;
use crate::{SwapOps, ValidateAddressResult};
use bitcrypto::sha256;
use common::block_on;
use common::executor::Timer;
use common::jsonrpc_client::{JsonRpcClient, JsonRpcErrorType, JsonRpcRequest, RpcRes};
use common::mm_metrics::MetricsArc;
use ethabi::{Function, Token};
use ethereum_types::{H160, U256};
use futures::{FutureExt, TryFutureExt};
use gstuff::now_ms;
use rpc::v1::types::H160 as H160Json;
use serialization::deserialize;
use std::ops::Neg;
use std::str::FromStr;
use utxo_common::HISTORY_TOO_LARGE_ERROR;

const QRC20_GAS_LIMIT_DEFAULT: u64 = 100_000;
const QRC20_GAS_PRICE_DEFAULT: u64 = 40;
const QRC20_SWAP_GAS_REQUIRED: u64 = 300_000;
const QRC20_DUST: u64 = 0;
// Keccak-256 hash of event Transfer
const QRC20_TRANSFER_TOPIC: &str = "ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef";
#[allow(dead_code)]
const QRC20_APPROVE_TOPIC: &str = "8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925";
/// Keccak-256 hash of "PaymentSent" event generated by swap contract.
#[allow(dead_code)]
const QRC20_PAYMENT_SENT: &str = "ccc9c05183599bd3135da606eaaf535daffe256e9de33c048014cffcccd4ad57";

#[derive(Debug, Deserialize, Eq, PartialEq)]
pub struct TokenInfo {
    name: String,
    decimals: u8,
    total_supply: u64,
    symbol: String,
}

#[derive(Debug, Deserialize)]
pub struct ExecutionResult {
    pub output: BytesJson,
}

#[derive(Debug, Deserialize)]
pub struct ContractCallResult {
    address: H160Json,
    #[serde(rename = "executionResult")]
    pub execution_result: ExecutionResult,
}

#[derive(Debug, Deserialize)]
pub struct TxHistoryItem {
    pub tx_hash: H256Json,
    pub height: i64,
    pub log_index: i64,
}

/// The structure is the same as Qtum Core RPC gettransactionreceipt returned data.
/// https://docs.qtum.site/en/Qtum-RPC-API/#gettransactionreceipt
#[derive(Debug, Deserialize)]
pub struct TxReceipt {
    /// Hash of the block this transaction was included within.
    #[serde(rename = "blockHash")]
    block_hash: H256Json,
    /// Number of the block this transaction was included within.
    #[serde(rename = "blockNumber")]
    block_number: i64,
    /// Transaction hash.
    #[serde(rename = "transactionHash")]
    transaction_hash: H256Json,
    /// Index within the block.
    #[serde(rename = "transactionIndex")]
    transaction_index: i64,
    /// Index within the outputs.
    #[serde(rename = "outputIndex")]
    output_index: i64,
    /// 20 bytes，the sender address of this tx.
    from: String,
    /// 20 bytes，the receiver address of this tx. if this  address is created by a contract, return null.
    #[serde(skip_serializing_if = "Option::is_none")]
    to: Option<String>,
    /// The total amount of gas used after execution of the current transaction.
    #[serde(rename = "cumulativeGasUsed")]
    cumulative_gas_used: u64,
    /// The gas cost alone to execute the current transaction.
    #[serde(rename = "gasUsed")]
    gas_used: i64,
    /// Contract address created, or `None` if not a deployment.
    #[serde(rename = "contractAddress")]
    contract_address: Option<String>,
    /// Logs generated within this transaction.
    log: Vec<LogEntry>,
    /// Whether corresponding contract call (specified in UTXO outputs[output_index]) was failed.
    /// If None or Some("None") - completed, else failed.
    excepted: Option<String>,
    #[serde(rename = "exceptedMessage")]
    excepted_message: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct LogEntry {
    /// Contract address.
    address: String,
    /// Vector of 0x-prefixed hex strings with length of 64.
    topics: Vec<String>,
    /// In other words the data means a transaction value.
    data: String,
}

/// QTUM specific RPC ops
pub trait QtumRpcOps {
    /// This can be used to get the basic information(name, decimals, total_supply, symbol) of a QRC20 token.
    /// https://github.com/qtumproject/qtum-electrumx-server/blob/master/docs/qrc20-integration.md#blockchaintokenget_infotoken_address
    fn blockchain_token_get_info(&self, token_addr: &H160Json) -> RpcRes<TokenInfo>;

    fn blockchain_contract_call(&self, contract_addr: &H160Json, data: BytesJson) -> RpcRes<ContractCallResult>;

    /// this can be used to retrieve QRC20 token transfer history, params are the same as blockchain.contract.event.subscribe,
    /// and it returns a list of map{tx_hash, height, log_index}, where log_index is the position for this event log in its transaction.
    /// https://github.com/qtumproject/qtum-electrumx-server/blob/master/docs/qrc20-integration.md#blockchaincontracteventget_historyhash160-contract_addr-topic
    fn blockchain_contract_event_get_history(
        &self,
        address: &H160Json,
        contract_addr: &H160Json,
        topic: &str,
    ) -> RpcRes<Vec<TxHistoryItem>>;

    fn blochchain_transaction_get_receipt(&self, hash: &H256Json) -> RpcRes<Vec<TxReceipt>>;
}

impl QtumRpcOps for ElectrumClient {
    fn blockchain_token_get_info(&self, token_addr: &H160Json) -> RpcRes<TokenInfo> {
        rpc_func!(self, "blockchain.token.get_info", token_addr)
    }

    fn blockchain_contract_call(&self, contract_addr: &H160Json, data: BytesJson) -> RpcRes<ContractCallResult> {
        let sender = "";
        rpc_func!(self, "blockchain.contract.call", contract_addr, data, sender)
    }

    fn blockchain_contract_event_get_history(
        &self,
        address: &H160Json,
        contract_addr: &H160Json,
        topic: &str,
    ) -> RpcRes<Vec<TxHistoryItem>> {
        rpc_func!(
            self,
            "blockchain.contract.event.get_history",
            address,
            contract_addr,
            topic
        )
    }

    fn blochchain_transaction_get_receipt(&self, hash: &H256Json) -> RpcRes<Vec<TxReceipt>> {
        rpc_func!(self, "blochchain.transaction.get_receipt", hash)
    }
}

#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
pub struct Qrc20FeeDetails {
    /// Coin name
    coin: String,
    /// Standard UTXO miner fee based on transaction size
    miner_fee: BigDecimal,
    /// in satoshi
    gas_limit: u64,
    gas_price: u64,
    total_gas_fee: BigDecimal,
}

pub async fn qrc20_coin_from_conf_and_request(
    ctx: &MmArc,
    ticker: &str,
    platform: &str,
    conf: &Json,
    req: &Json,
    priv_key: &[u8],
    contract_address: H160,
) -> Result<Qrc20Coin, String> {
    if let Some("enable") = req["method"].as_str() {
        return ERR!("Native mode not supported yet for QRC20");
    }
    let swap_contract_address = match req["swap_contract_address"].as_str() {
        Some(address) => try_s!(qrc20_addr_from_str(address)),
        None => return ERR!("\"swap_contract_address\" field is expected"),
    };
    let inner = try_s!(utxo_arc_from_conf_and_request(ctx, ticker, conf, req, priv_key, QRC20_DUST).await);
    match &inner.address_format {
        UtxoAddressFormat::Standard => (),
        _ => return ERR!("Expect standard UTXO address format"),
    }
    let platform = platform.to_owned();
    Ok(Qrc20Coin {
        utxo_arc: inner,
        platform,
        contract_address,
        swap_contract_address,
    })
}

#[derive(Clone, Debug)]
pub struct Qrc20Coin {
    pub utxo_arc: UtxoArc,
    pub platform: String,
    pub contract_address: H160,
    pub swap_contract_address: H160,
}

enum RpcContractCallType {
    /// Erc20 function.
    BalanceOf,
    /// Erc20 function.
    Allowance,
    /// EtomicSwap function.
    Payments,
}

impl Qrc20Coin {
    async fn rpc_contract_call(&self, func: RpcContractCallType, tokens: &[Token]) -> Result<Vec<Token>, String> {
        let (function, contract_addr) = match func {
            RpcContractCallType::BalanceOf => {
                let function = try_s!(ERC20_CONTRACT.function("balanceOf"));
                let contract_addr = qrc20_addr_into_rpc_format(&self.contract_address);
                (function, contract_addr)
            },
            RpcContractCallType::Allowance => {
                let function = try_s!(ERC20_CONTRACT.function("allowance"));
                let contract_addr = qrc20_addr_into_rpc_format(&self.contract_address);
                (function, contract_addr)
            },
            RpcContractCallType::Payments => {
                let function = try_s!(SWAP_CONTRACT.function("payments"));
                let contract_addr = qrc20_addr_into_rpc_format(&self.swap_contract_address);
                (function, contract_addr)
            },
        };
        let params = try_s!(function.encode_input(tokens));

        let electrum = match self.utxo_arc.rpc_client {
            UtxoRpcClientEnum::Electrum(ref electrum) => electrum,
            _ => return ERR!("Electrum client expected"),
        };

        let result: ContractCallResult = try_s!(
            electrum
                .blockchain_contract_call(&contract_addr, params.into())
                .compat()
                .await
        );
        Ok(try_s!(function.decode_output(&result.execution_result.output)))
    }

    pub fn utxo_address_from_qrc20(&self, address: H160) -> Address {
        let utxo = self.as_ref();
        Address {
            prefix: utxo.pub_addr_prefix,
            t_addr_prefix: utxo.pub_t_addr_prefix,
            hash: address.0.into(),
            checksum_type: utxo.checksum_type,
        }
    }

    pub fn utxo_address_from_raw_pubkey(&self, pubkey: &[u8]) -> Result<Address, String> {
        Ok(try_s!(utxo_common::address_from_raw_pubkey(
            pubkey,
            self.utxo_arc.pub_addr_prefix,
            self.utxo_arc.pub_t_addr_prefix,
            self.utxo_arc.checksum_type
        )))
    }

    pub fn qrc20_address_from_raw_pubkey(&self, pubkey: &[u8]) -> Result<H160, String> {
        let qtum_address = try_s!(self.utxo_address_from_raw_pubkey(pubkey));
        Ok(qrc20_addr_from_utxo_addr(qtum_address))
    }

    /// Get `Transfer` event details from [`TxReceipt::logs`].
    fn transfer_call_details_from_receipt(&self, receipt: &TxReceipt) -> Result<(BigDecimal, H160, H160), String> {
        fn address_from_log_topic(topic: &str) -> Result<H160, String> {
            if topic.len() != 64 {
                return ERR!(
                    "Topic {:?} is expected to be H256 encoded topic (with length of 64)",
                    topic
                );
            }

            // skip the first 24 characters to parse the last 40 characters to H160.
            // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2112
            let hash = try_s!(H160Json::from_str(&topic[24..]));
            Ok(hash.0.into())
        }

        // We can get a log_index from get_history call, but it is overhead to request it on every tx_details_by_hash(),
        // because of this try to find corresponding log entry below
        let log = match receipt.log.iter().find(|log_entry| {
            // we should find a log entry with three and more topics
            if log_entry.topics.len() < 3 {
                return false;
            }
            // the first topic means the type of the contract call
            // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2101
            log_entry.topics.first().unwrap() == QRC20_TRANSFER_TOPIC
        }) {
            Some(log) => log,
            _ => return ERR!("Couldn't find a log entry that meets the requirements"),
        };

        let amount = try_s!(U256::from_str(&log.data));
        // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2111
        let amount = try_s!(u256_to_big_decimal(amount, self.decimals()));

        // log.topics[i < 3] is safe because of the checking above
        // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2112
        let from = try_s!(address_from_log_topic(&log.topics[1]));
        // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2113
        let to = try_s!(address_from_log_topic(&log.topics[2]));
        Ok((amount, from, to))
    }

    /// Get `transfer` contract call details from script pubkey.
    fn transfer_call_details_from_script_pubkey(&self, script_pubkey: &Script) -> Result<(H160, U256), String> {
        if !is_contract_call(&script_pubkey) {
            return ERR!("Expected 'transfer' contract call");
        }

        let contract_call_bytes = try_s!(extract_contract_call_from_script(&script_pubkey));
        let call_type = try_s!(ContractCallType::from_script_pubkey(&contract_call_bytes));
        match call_type {
            Some(ContractCallType::Transfer) => (),
            _ => return ERR!("Expected 'transfer' contract call"),
        }

        let function = try_s!(ERC20_CONTRACT.function("transfer"));
        let decoded = try_s!(function.decode_input(&contract_call_bytes));
        let mut decoded = decoded.into_iter();

        let receiver = match decoded.next() {
            Some(Token::Address(addr)) => addr,
            Some(token) => return ERR!("Transfer 'receiver' arg is invalid, found {:?}", token),
            None => return ERR!("Couldn't find 'receiver' in 'transfer' call"),
        };

        let value = match decoded.next() {
            Some(Token::Uint(value)) => value,
            Some(token) => return ERR!("Transfer 'value' arg is invalid, found {:?}", token),
            None => return ERR!("Couldn't find 'value' in 'transfer' call"),
        };

        Ok((receiver, value))
    }

    pub async fn allowance(&self, spender: H160) -> Result<U256, String> {
        let tokens = try_s!(
            self.rpc_contract_call(RpcContractCallType::Allowance, &[
                Token::Address(qrc20_addr_from_utxo_addr(self.utxo_arc.my_address.clone())),
                Token::Address(spender),
            ])
            .await
        );

        if tokens.is_empty() {
            return ERR!(r#"Expected U256 as "allowance" result but got nothing"#);
        }

        match tokens[0] {
            Token::Uint(number) => Ok(number),
            _ => ERR!(r#"Expected U256 as "allowance" result but got {:?}"#, tokens),
        }
    }

    pub async fn payment_status(&self, swap_id: Vec<u8>) -> Result<U256, String> {
        let decoded = try_s!(
            self.rpc_contract_call(RpcContractCallType::Payments, &[Token::FixedBytes(swap_id)])
                .await
        );
        if decoded.len() < 3 {
            return ERR!(
                "Expected at least 3 tokens in \"payments\" call, found {}",
                decoded.len()
            );
        }

        match decoded[2] {
            Token::Uint(state) => Ok(state),
            _ => ERR!("Payment status must be uint, got {:?}", decoded[2]),
        }
    }

    pub fn transfer_output(
        &self,
        to_addr: H160,
        amount: U256,
        gas_limit: u64,
        gas_price: u64,
    ) -> Result<TransactionOutput, String> {
        let function = try_s!(ERC20_CONTRACT.function("transfer"));
        let params = try_s!(function.encode_input(&[Token::Address(to_addr), Token::Uint(amount)]));

        let script_pubkey = try_s!(generate_contract_call_script_pubkey(
            &params,
            gas_limit,
            gas_price,
            &self.contract_address,
        ))
        .to_bytes();

        // qtum_amount is always 0 for the QRC20, because we should pay only a fee in Qtum to send the QRC20 transaction
        let qtum_amount = 0;
        Ok(TransactionOutput {
            value: qtum_amount,
            script_pubkey,
        })
    }

    /// Generate a UTXO output with a script_pubkey that calls standard QRC20 `approve` function.
    pub fn approve_output(&self, spender: H160, amount: U256) -> Result<TransactionOutput, String> {
        let function = try_s!(ERC20_CONTRACT.function("approve"));
        let params = try_s!(function.encode_input(&[Token::Address(spender), Token::Uint(amount)]));

        let script_pubkey = try_s!(generate_contract_call_script_pubkey(
            &params,
            QRC20_GAS_LIMIT_DEFAULT,
            QRC20_GAS_PRICE_DEFAULT,
            &self.contract_address
        ))
        .to_bytes();

        // qtum_amount is always 0 for the QRC20, because we should pay only a fee in Qtum to send the QRC20 transaction
        let qtum_amount = 0;
        Ok(TransactionOutput {
            value: qtum_amount,
            script_pubkey,
        })
    }

    /// Generate a UTXO output with a script_pubkey that calls EtomicSwap `erc20Payment` function.
    pub fn erc20_payment_output(
        &self,
        id: Vec<u8>,
        value: U256,
        time_lock: u32,
        secret_hash: &[u8],
        receiver_addr: H160,
    ) -> Result<TransactionOutput, String> {
        let function = try_s!(SWAP_CONTRACT.function("erc20Payment"));
        let params = try_s!(function.encode_input(&[
            Token::FixedBytes(id),
            Token::Uint(value),
            Token::Address(self.contract_address),
            Token::Address(receiver_addr),
            Token::FixedBytes(secret_hash.to_vec()),
            Token::Uint(U256::from(time_lock))
        ]));

        let script_pubkey = try_s!(generate_contract_call_script_pubkey(
            &params, // params of the function
            QRC20_GAS_LIMIT_DEFAULT,
            QRC20_GAS_PRICE_DEFAULT,
            &self.swap_contract_address, // address of the contract which function will be called
        ))
        .to_bytes();

        // qtum_amount is always 0 for the QRC20, because we should pay only a fee in Qtum to send the QRC20 transaction
        let qtum_amount = 0;
        Ok(TransactionOutput {
            value: qtum_amount,
            script_pubkey,
        })
    }

    /// Generate a UTXO output with a script_pubkey that calls EtomicSwap `receiverSpend` function.
    pub fn receiver_spend_output(
        &self,
        id: Vec<u8>,
        value: U256,
        secret: Vec<u8>,
        sender_addr: H160,
    ) -> Result<TransactionOutput, String> {
        let function = try_s!(SWAP_CONTRACT.function("receiverSpend"));
        let params = try_s!(function.encode_input(&[
            Token::FixedBytes(id),
            Token::Uint(value),
            Token::FixedBytes(secret),
            Token::Address(self.contract_address),
            Token::Address(sender_addr)
        ]));

        let script_pubkey = try_s!(generate_contract_call_script_pubkey(
            &params, // params of the function
            QRC20_GAS_LIMIT_DEFAULT,
            QRC20_GAS_PRICE_DEFAULT,
            &self.swap_contract_address, // address of the contract which function will be called
        ))
        .to_bytes();

        // qtum_amount is always 0 for the QRC20, because we should pay only a fee in Qtum to send the QRC20 transaction
        let qtum_amount = 0;
        Ok(TransactionOutput {
            value: qtum_amount,
            script_pubkey,
        })
    }

    pub fn sender_refund_output(
        &self,
        id: Vec<u8>,
        value: U256,
        secret_hash: Vec<u8>,
        receiver: H160,
    ) -> Result<TransactionOutput, String> {
        let function = try_s!(SWAP_CONTRACT.function("senderRefund"));

        let params = try_s!(function.encode_input(&[
            Token::FixedBytes(id),
            Token::Uint(value),
            Token::FixedBytes(secret_hash),
            Token::Address(self.contract_address),
            Token::Address(receiver)
        ]));

        let script_pubkey = try_s!(generate_contract_call_script_pubkey(
            &params, // params of the function
            QRC20_GAS_LIMIT_DEFAULT,
            QRC20_GAS_PRICE_DEFAULT,
            &self.swap_contract_address, // address of the contract which function will be called
        ))
        .to_bytes();

        // qtum_amount is always 0 for the QRC20, because we should pay only a fee in Qtum to send the QRC20 transaction
        let qtum_amount = 0;
        Ok(TransactionOutput {
            value: qtum_amount,
            script_pubkey,
        })
    }

    /// Generate and send a transaction from the specified UTXO outputs.
    /// Note this function locks the `UTXO_LOCK`.
    pub async fn send_contract_calls(
        &self,
        // TODO replace TransactionOutput with a ContractCallOutput
        outputs: Vec<TransactionOutput>,
    ) -> Result<TransactionEnum, String> {
        let _utxo_lock = UTXO_LOCK.lock().await;

        let (signed, _fee_details) = try_s!(
            self.generate_qrc20_transaction(QRC20_GAS_LIMIT_DEFAULT, QRC20_GAS_PRICE_DEFAULT, outputs)
                .await
        );
        let _tx = try_s!(
            self.utxo_arc
                .rpc_client
                .send_transaction(&signed, self.utxo_arc.my_address.clone())
                .compat()
                .await
        );
        Ok(signed.into())
    }

    /// Generate Qtum UTXO transaction to call QRC20 contract call such as `transfer` or `approve`.
    /// Note: lock the UTXO_LOCK mutex before this function will be called.
    async fn generate_qrc20_transaction(
        &self,
        gas_limit: u64,
        gas_price: u64,
        outputs: Vec<TransactionOutput>,
    ) -> Result<(UtxoTx, Qrc20FeeDetails), String> {
        let unspents = try_s!(self
            .ordered_mature_unspents(&self.utxo_arc.my_address)
            .compat()
            .await
            .map_err(|e| ERRL!("{}", e)));

        // None seems that the generate_transaction() should request estimated fee for Kbyte
        let actual_tx_fee = None;
        // We do one contract call, because of this gas_fee will be (1 * gas_limit * gas_price)
        let gas_fee = gas_limit
            .checked_mul(gas_price)
            .ok_or(ERRL!("too large gas_limit and/or gas_price"))?
            .checked_mul(outputs.len() as u64)
            .ok_or(ERRL!("too large gas_fee"))?;
        let fee_policy = FeePolicy::SendExact;

        let (unsigned, data) = self
            .generate_transaction(unspents, outputs, fee_policy, actual_tx_fee, Some(gas_fee))
            .await
            .map_err(|e| match &e {
                GenerateTransactionError::EmptyUtxoSet => ERRL!("Not enough {} to Pay Fee: {}", self.platform, e),
                GenerateTransactionError::NotSufficientBalance { description } => {
                    ERRL!("Not enough {} to Pay Fee: {}", self.platform, description)
                },
                e => ERRL!("{}", e),
            })?;
        let prev_script = Builder::build_p2pkh(&self.utxo_arc.my_address.hash);
        let signed = try_s!(sign_tx(
            unsigned,
            &self.utxo_arc.key_pair,
            prev_script,
            self.utxo_arc.signature_version,
            self.utxo_arc.fork_id
        ));
        let fee_details = Qrc20FeeDetails {
            // QRC20 fees are paid in base platform currency (in particular Qtum)
            coin: self.platform.clone(),
            miner_fee: utxo_common::big_decimal_from_sat(data.fee_amount as i64, self.utxo_arc.decimals),
            gas_limit,
            gas_price,
            total_gas_fee: utxo_common::big_decimal_from_sat(gas_fee as i64, self.utxo_arc.decimals),
        };
        Ok((signed, fee_details))
    }

    /// Get `erc20Payment` contract call details.
    /// Note returns an error if the contract call was excepted.
    async fn erc20_payment_details_from_tx(&self, qtum_tx: &UtxoTx) -> Result<Erc20PaymentDetails, String> {
        let tx_hash: H256Json = qtum_tx.hash().reversed().into();
        let receipts = match self.utxo_arc.rpc_client {
            UtxoRpcClientEnum::Electrum(ref rpc) => {
                try_s!(rpc.blochchain_transaction_get_receipt(&tx_hash).compat().await)
            },
            UtxoRpcClientEnum::Native(_) => return ERR!("Electrum client expected"),
        };

        for receipt in receipts {
            let output = try_s!(qtum_tx
                .outputs
                .get(receipt.output_index as usize)
                .ok_or(ERRL!("TxReceipt::output_index out of bounds")));
            let script_pubkey: Script = output.script_pubkey.clone().into();
            if !is_contract_call(&script_pubkey) {
                continue;
            }

            let contract_call_bytes = try_s!(extract_contract_call_from_script(&script_pubkey));

            let call_type = try_s!(ContractCallType::from_script_pubkey(&contract_call_bytes));
            match call_type {
                Some(ContractCallType::Erc20Payment) => (),
                _ => continue, // skip non-erc20Payment contract calls
            }

            // check if the contract call was excepted
            match receipt.excepted.clone() {
                Some(ex) if ex != "None" && ex != "none" => {
                    let msg = match receipt.excepted_message {
                        Some(m) => format!(": {}", m),
                        None => String::default(),
                    };
                    return ERR!("'erc20Payment' payment failed with an error: {}{}", ex, msg);
                },
                _ => (),
            }

            let function = try_s!(SWAP_CONTRACT.function("erc20Payment"));
            let decoded = try_s!(function.decode_input(&contract_call_bytes));

            let mut decoded = decoded.into_iter();

            let swap_id = match decoded.next() {
                Some(Token::FixedBytes(id)) => id,
                Some(token) => return ERR!("Payment tx 'swap_id' arg is invalid, found {:?}", token),
                None => return ERR!("Couldn't find 'swap_id' in erc20Payment call"),
            };

            let value = match decoded.next() {
                Some(Token::Uint(value)) => value,
                Some(token) => return ERR!("Payment tx 'value' arg is invalid, found {:?}", token),
                None => return ERR!("Couldn't find 'value' in erc20Payment call"),
            };

            let token_address = match decoded.next() {
                Some(Token::Address(addr)) => addr,
                Some(token) => return ERR!("Payment tx 'token_address' arg is invalid, found {:?}", token),
                None => return ERR!("Couldn't find 'token_address' in erc20Payment call"),
            };

            let receiver = match decoded.next() {
                Some(Token::Address(addr)) => addr,
                Some(token) => return ERR!("Payment tx 'receiver' arg is invalid, found {:?}", token),
                None => return ERR!("Couldn't find 'receiver' in erc20Payment call"),
            };

            let secret_hash = match decoded.next() {
                Some(Token::FixedBytes(hash)) => hash,
                Some(token) => return ERR!("Payment tx 'secret_hash' arg is invalid, found {:?}", token),
                None => return ERR!("Couldn't find 'secret_hash' in erc20Payment call"),
            };

            let timelock = match decoded.next() {
                Some(Token::Uint(t)) => t,
                Some(token) => return ERR!("Payment tx 'timelock' arg is invalid, found {:?}", token),
                None => return ERR!("Couldn't find 'timelock' in erc20Payment call"),
            };

            let (_amount, sender, swap_contract_address) = try_s!(self.transfer_call_details_from_receipt(&receipt));
            return Ok(Erc20PaymentDetails {
                output_index: receipt.output_index,
                swap_id,
                value,
                token_address,
                swap_contract_address,
                sender,
                receiver,
                secret_hash,
                timelock,
            });
        }
        ERR!("Couldn't find erc20Payment contract call in {:?} tx", tx_hash)
    }

    /// Search a UTXO tx that contains a contract call in outputs using the specified `expected_swap_id` and `expected_call_type`.
    /// Note contract calls within transaction history might have a different script pubkey structure (cause another `EtomicSwap` contract),
    /// because of this the function returns fatal error only (couldn't request a history, etc).
    async fn search_swap_tx_by_call_type_and_swap_id(
        &self,
        expected_call_type: &ContractCallType,
        expected_swap_id: &[u8],
        sender: &H160,
        search_from_block: u64,
    ) -> Result<Option<UtxoTx>, String> {
        /// The helper function.
        /// Note returns fatal error only.
        fn try_find_contract_call(
            tx: &UtxoTx,
            expected_swap_id: &[u8],
            expected_call_type: &ContractCallType,
        ) -> Result<Option<usize>, String> {
            let tx_hash: H256Json = tx.hash().reversed().into();

            for (output_index, output) in tx.outputs.iter().enumerate() {
                let script_pubkey: Script = output.script_pubkey.clone().into();
                if !is_contract_call(&script_pubkey) {
                    continue;
                }

                let contract_call_bytes = match extract_contract_call_from_script(&script_pubkey) {
                    Ok(bytes) => bytes,
                    Err(e) => {
                        log!([e]);
                        continue;
                    },
                };

                let call_type = match ContractCallType::from_script_pubkey(&contract_call_bytes) {
                    Ok(Some(t)) => t,
                    Ok(None) => continue, // unknown contract call type
                    Err(e) => {
                        log!([e]);
                        continue;
                    },
                };
                if call_type != *expected_call_type {
                    // skip the output
                    continue;
                }

                let function = call_type.as_function();
                let decoded = try_s!(function.decode_input(&contract_call_bytes));

                // swap_id is the first in all of the EtomicSwap contract methods
                let swap_id = match decoded.into_iter().next() {
                    Some(Token::FixedBytes(id)) => id,
                    Some(token) => {
                        log!("Error: Payment tx "[tx_hash]" 'swap_id' arg is invalid, found "[token]);
                        continue;
                    },
                    None => {
                        log!("Couldn't find 'swap_id' in "[tx_hash]);
                        continue;
                    },
                };

                if swap_id == expected_swap_id {
                    return Ok(Some(output_index));
                }
            }

            Ok(None)
        }

        let electrum = match self.utxo_arc.rpc_client {
            UtxoRpcClientEnum::Electrum(ref rpc_cln) => rpc_cln,

            UtxoRpcClientEnum::Native(_) => {
                return ERR!("Native mode not supported");
            },
        };

        let sender = qrc20_addr_into_rpc_format(sender);
        let contract_address = qrc20_addr_into_rpc_format(&self.contract_address);

        let history = try_s!(
            electrum
                .blockchain_contract_event_get_history(&sender, &contract_address, QRC20_TRANSFER_TOPIC)
                .compat()
                .await
        );

        for entry in history {
            if (entry.height as u64) < search_from_block {
                continue;
            }

            let verbose_tx = match electrum.get_verbose_transaction(entry.tx_hash.clone()).compat().await {
                Ok(tx) => tx,
                Err(e) => {
                    log!("Error on get_verbose_transaction(" [entry.tx_hash] "): " [e]);
                    continue;
                },
            };
            let qtum_tx: UtxoTx = match deserialize(verbose_tx.hex.as_slice()) {
                Ok(tx) => tx,
                Err(e) => {
                    log!("Error on deserialize a Qtum tx_hex: "[verbose_tx.hex] ". Error: " [e]);
                    continue;
                },
            };
            // use try_s!(), because the `try_find_contract_call` can fails with fatal error only
            if let Some(_output_index) = try_s!(try_find_contract_call(&qtum_tx, expected_swap_id, expected_call_type))
            {
                return Ok(Some(qtum_tx));
            }
        }

        Ok(None)
    }
}

#[derive(Debug, Eq, PartialEq)]
pub enum ContractCallType {
    Transfer,
    Erc20Payment,
    ReceiverSpend,
    SenderRefund,
}

impl ContractCallType {
    fn as_function_name(&self) -> &'static str {
        match self {
            ContractCallType::Transfer => "transfer",
            ContractCallType::Erc20Payment => "erc20Payment",
            ContractCallType::ReceiverSpend => "receiverSpend",
            ContractCallType::SenderRefund => "senderRefund",
        }
    }

    fn as_function(&self) -> &'static Function {
        match self {
            ContractCallType::Transfer => unwrap!(ERC20_CONTRACT.function(self.as_function_name())),
            ContractCallType::Erc20Payment | ContractCallType::ReceiverSpend | ContractCallType::SenderRefund => {
                unwrap!(SWAP_CONTRACT.function(self.as_function_name()))
            },
        }
    }

    fn from_script_pubkey(script: &[u8]) -> Result<Option<ContractCallType>, String> {
        if script.len() < 4 {
            return ERR!("Length of the script pubkey less than 4: {:?}", script);
        }

        // Result of (ContractCallType::Transfer).short_signature()
        // in hex: a9059cbb
        if script.starts_with(&[169, 5, 156, 187]) {
            return Ok(Some(ContractCallType::Transfer));
        }

        // Result of (ContractCallType::Erc20Payment).short_signature()
        // in hex: 9b415b2a
        if script.starts_with(&[155, 65, 91, 42]) {
            return Ok(Some(ContractCallType::Erc20Payment));
        }

        // Result of (ContractCallType::ReceiverSpend).short_signature()
        // in hex: 02ed292b
        if script.starts_with(&[2, 237, 41, 43]) {
            return Ok(Some(ContractCallType::ReceiverSpend));
        }

        // Result of (ContractCallType::SenderRefund).short_signature()
        // in hex: 46fc0294
        if script.starts_with(&[70, 252, 2, 148]) {
            return Ok(Some(ContractCallType::SenderRefund));
        }

        Ok(None)
    }

    #[allow(dead_code)]
    fn short_signature(&self) -> [u8; 4] { self.as_function().short_signature() }
}

/// These variants contain values obtained from an [`TransactionOutput::script_pubkey`] and [`TxReceipt::logs`].
#[derive(Debug, Eq, PartialEq)]
pub struct Erc20PaymentDetails {
    pub output_index: i64,
    pub swap_id: Vec<u8>,
    pub value: U256,
    pub token_address: H160,
    pub swap_contract_address: H160,
    pub sender: H160,
    pub receiver: H160,
    pub secret_hash: Vec<u8>,
    pub timelock: U256,
}

impl AsRef<UtxoArc> for Qrc20Coin {
    fn as_ref(&self) -> &UtxoArc { &self.utxo_arc }
}

#[async_trait]
impl UtxoCoinCommonOps for Qrc20Coin {
    async fn get_tx_fee(&self) -> Result<ActualTxFee, JsonRpcError> { utxo_common::get_tx_fee(&self.utxo_arc).await }

    async fn get_htlc_spend_fee(&self) -> Result<u64, String> { utxo_common::get_htlc_spend_fee(self).await }

    fn addresses_from_script(&self, script: &Script) -> Result<Vec<Address>, String> {
        utxo_common::addresses_from_script(&self.utxo_arc, script)
    }

    fn denominate_satoshis(&self, satoshi: i64) -> f64 { utxo_common::denominate_satoshis(&self.utxo_arc, satoshi) }

    fn my_public_key(&self) -> &Public { self.utxo_arc.key_pair.public() }

    fn display_address(&self, address: &Address) -> Result<String, String> {
        utxo_common::display_address(&self.utxo_arc, address)
    }

    fn try_address_from_str(&self, from: &str) -> Result<Address, String> {
        utxo_common::try_address_from_str(&self.utxo_arc, from)
    }

    fn address_from_str(&self, address: &str) -> Result<Address, String> {
        utxo_common::address_from_str(&self.utxo_arc, address)
    }

    async fn get_current_mtp(&self) -> Result<u32, String> { utxo_common::get_current_mtp(&self.utxo_arc).await }

    fn is_unspent_mature(&self, output: &RpcTransaction) -> bool {
        qtum::is_qtum_unspent_mature(self.utxo_arc.mature_confirmations, output)
    }
}

#[mockable]
#[async_trait]
#[allow(clippy::forget_ref, clippy::forget_copy)]
impl UtxoArcCommonOps for Qrc20Coin {
    /// Generate UTXO transaction with specified unspent inputs and specified outputs.
    async fn generate_transaction(
        &self,
        utxos: Vec<UnspentInfo>,
        outputs: Vec<TransactionOutput>,
        fee_policy: FeePolicy,
        fee: Option<ActualTxFee>,
        gas_fee: Option<u64>,
    ) -> Result<(TransactionInputSigner, AdditionalTxData), GenerateTransactionError> {
        utxo_common::generate_transaction(self, utxos, outputs, fee_policy, fee, gas_fee).await
    }

    async fn calc_interest_if_required(
        &self,
        unsigned: TransactionInputSigner,
        data: AdditionalTxData,
        my_script_pub: Bytes,
    ) -> Result<(TransactionInputSigner, AdditionalTxData), String> {
        utxo_common::calc_interest_if_required(self, unsigned, data, my_script_pub).await
    }

    fn p2sh_spending_tx(
        &self,
        prev_transaction: UtxoTx,
        redeem_script: Bytes,
        outputs: Vec<TransactionOutput>,
        script_data: Script,
        sequence: u32,
    ) -> Result<UtxoTx, String> {
        utxo_common::p2sh_spending_tx(
            &self.utxo_arc,
            prev_transaction,
            redeem_script,
            outputs,
            script_data,
            sequence,
        )
    }

    fn ordered_mature_unspents(
        &self,
        address: &Address,
    ) -> Box<dyn Future<Item = Vec<UnspentInfo>, Error = String> + Send> {
        Box::new(
            utxo_common::ordered_mature_unspents(self.clone(), address.clone())
                .boxed()
                .compat(),
        )
    }

    fn get_verbose_transaction_from_cache_or_rpc(
        &self,
        txid: H256Json,
    ) -> Box<dyn Future<Item = VerboseTransactionFrom, Error = String> + Send> {
        Box::new(
            utxo_common::get_verbose_transaction_from_cache_or_rpc(self.clone(), txid)
                .boxed()
                .compat(),
        )
    }

    async fn request_tx_history(&self, metrics: MetricsArc) -> RequestTxHistoryResult {
        let tx_ids = match &self.utxo_arc.rpc_client {
            UtxoRpcClientEnum::Native(_client) => {
                // it should not be happened because qrc20_coin_from_conf_and_request() must not allow enable mode
                return RequestTxHistoryResult::UnknownError(ERRL!("Native mode not supported"));
            },
            UtxoRpcClientEnum::Electrum(client) => {
                let my_address = utxo_addr_into_rpc_format(self.utxo_arc.my_address.clone());
                let contract_addr = qrc20_addr_into_rpc_format(&self.contract_address);

                mm_counter!(metrics, "tx.history.request.count", 1,
                    "coin" => self.utxo_arc.ticker.clone(), "client" => "electrum", "method" => "blockchain.contract.event.get_history");

                let history = match client
                    .blockchain_contract_event_get_history(&my_address, &contract_addr, QRC20_TRANSFER_TOPIC)
                    .compat()
                    .await
                {
                    Ok(value) => value,
                    Err(e) => match &e.error {
                        JsonRpcErrorType::Transport(e) | JsonRpcErrorType::Parse(_, e) => {
                            return RequestTxHistoryResult::Retry {
                                error: ERRL!("Error {} on blockchain_contract_event_get_history", e),
                            };
                        },
                        JsonRpcErrorType::Response(_addr, err) => {
                            if HISTORY_TOO_LARGE_ERROR.eq(err) {
                                return RequestTxHistoryResult::HistoryTooLarge;
                            } else {
                                return RequestTxHistoryResult::Retry {
                                    error: ERRL!("Error {:?} on blockchain_contract_event_get_history", e),
                                };
                            }
                        },
                    },
                };
                mm_counter!(metrics, "tx.history.response.count", 1,
                    "coin" => self.utxo_arc.ticker.clone(), "client" => "electrum", "method" => "blockchain.contract.event.get_history");

                mm_counter!(metrics, "tx.history.response.total_length", history.len() as u64,
                    "coin" => self.utxo_arc.ticker.clone(), "client" => "electrum", "method" => "blockchain.contract.event.get_history");

                // electrum returns the most recent transactions in the end but we need to
                // process them first so rev is required
                history
                    .into_iter()
                    .rev()
                    .map(|item| {
                        let height = if item.height < 0 { 0 } else { item.height as u64 };
                        (item.tx_hash, height)
                    })
                    .collect()
            },
        };
        RequestTxHistoryResult::Ok(tx_ids)
    }
}

impl SwapOps for Qrc20Coin {
    fn send_taker_fee(&self, fee_addr: &[u8], amount: BigDecimal) -> TransactionFut {
        let to_address = try_fus!(self.qrc20_address_from_raw_pubkey(fee_addr));
        let amount = try_fus!(wei_from_big_decimal(&amount, self.utxo_arc.decimals));
        let transfer_output =
            try_fus!(self.transfer_output(to_address, amount, QRC20_GAS_LIMIT_DEFAULT, QRC20_GAS_PRICE_DEFAULT));
        let outputs = vec![transfer_output];

        let selfi = self.clone();
        let fut = async move { selfi.send_contract_calls(outputs).await };

        Box::new(fut.boxed().compat())
    }

    fn send_maker_payment(
        &self,
        time_lock: u32,
        taker_pub: &[u8],
        secret_hash: &[u8],
        amount: BigDecimal,
    ) -> TransactionFut {
        let taker_addr = try_fus!(self.qrc20_address_from_raw_pubkey(taker_pub));
        let id = qrc20_swap_id(time_lock, secret_hash);
        let value = try_fus!(wei_from_big_decimal(&amount, self.utxo_arc.decimals));
        let secret_hash = Vec::from(secret_hash);
        Box::new(
            qrc20_send_hash_time_locked_payment(self.clone(), id, value, time_lock, secret_hash, taker_addr)
                .boxed()
                .compat(),
        )
    }

    fn send_taker_payment(
        &self,
        time_lock: u32,
        maker_pub: &[u8],
        secret_hash: &[u8],
        amount: BigDecimal,
    ) -> TransactionFut {
        let maker_addr = try_fus!(self.qrc20_address_from_raw_pubkey(maker_pub));
        let id = qrc20_swap_id(time_lock, secret_hash);
        let value = try_fus!(wei_from_big_decimal(&amount, self.utxo_arc.decimals));
        let secret_hash = Vec::from(secret_hash);
        Box::new(
            qrc20_send_hash_time_locked_payment(self.clone(), id, value, time_lock, secret_hash, maker_addr)
                .boxed()
                .compat(),
        )
    }

    fn send_maker_spends_taker_payment(
        &self,
        taker_payment_tx: &[u8],
        _time_lock: u32,
        _taker_pub: &[u8],
        secret: &[u8],
    ) -> TransactionFut {
        let payment_tx: UtxoTx = try_fus!(deserialize(taker_payment_tx).map_err(|e| ERRL!("{:?}", e)));
        Box::new(
            qrc20_spend_hash_time_locked_payment(self.clone(), payment_tx, secret.to_vec())
                .boxed()
                .compat(),
        )
    }

    fn send_taker_spends_maker_payment(
        &self,
        maker_payment_tx: &[u8],
        _time_lock: u32,
        _maker_pub: &[u8],
        secret: &[u8],
    ) -> TransactionFut {
        let payment_tx: UtxoTx = try_fus!(deserialize(maker_payment_tx).map_err(|e| ERRL!("{:?}", e)));
        Box::new(
            qrc20_spend_hash_time_locked_payment(self.clone(), payment_tx, secret.to_vec())
                .boxed()
                .compat(),
        )
    }

    fn send_taker_refunds_payment(
        &self,
        taker_payment_tx: &[u8],
        _time_lock: u32,
        _maker_pub: &[u8],
        _secret_hash: &[u8],
    ) -> TransactionFut {
        let payment_tx: UtxoTx = try_fus!(deserialize(taker_payment_tx).map_err(|e| ERRL!("{:?}", e)));
        Box::new(
            qrc20_refund_hash_time_locked_payment(self.clone(), payment_tx)
                .boxed()
                .compat(),
        )
    }

    fn send_maker_refunds_payment(
        &self,
        maker_payment_tx: &[u8],
        _time_lock: u32,
        _taker_pub: &[u8],
        _secret_hash: &[u8],
    ) -> TransactionFut {
        let payment_tx: UtxoTx = try_fus!(deserialize(maker_payment_tx).map_err(|e| ERRL!("{:?}", e)));
        Box::new(
            qrc20_refund_hash_time_locked_payment(self.clone(), payment_tx)
                .boxed()
                .compat(),
        )
    }

    fn validate_fee(
        &self,
        fee_tx: &TransactionEnum,
        fee_addr: &[u8],
        amount: &BigDecimal,
    ) -> Box<dyn Future<Item = (), Error = String> + Send> {
        let fee_tx_hash: H256Json = match fee_tx {
            TransactionEnum::UtxoTx(tx) => tx.hash().reversed().into(),
            _ => panic!("Unexpected TransactionEnum"),
        };
        let fee_addr = try_fus!(self.qrc20_address_from_raw_pubkey(fee_addr));
        let expected_value = try_fus!(wei_from_big_decimal(amount, self.utxo_arc.decimals));

        let selfi = self.clone();
        let fut = async move {
            let verbose_tx = match selfi.utxo_arc.rpc_client {
                UtxoRpcClientEnum::Electrum(ref rpc) => try_s!(rpc.get_verbose_transaction(fee_tx_hash).compat().await),
                UtxoRpcClientEnum::Native(_) => return ERR!("Electrum client expected"),
            };
            let qtum_tx: UtxoTx = try_s!(deserialize(verbose_tx.hex.as_slice()).map_err(|e| ERRL!("{:?}", e)));

            // The transaction could not being mined, just check the transfer tokens.
            let output = qtum_tx
                .outputs
                .first()
                .ok_or(ERRL!("Provided dex fee tx {:?} has no outputs", qtum_tx))?;
            let script_pubkey: Script = output.script_pubkey.clone().into();

            let (receiver, value) = match selfi.transfer_call_details_from_script_pubkey(&script_pubkey) {
                Ok((rec, val)) => (rec, val),
                Err(e) => return ERR!("Provided dex fee tx {:?} is incorrect: {}", qtum_tx, e),
            };

            if receiver != fee_addr {
                return ERR!(
                    "QRC20 Fee tx was sent to wrong address {:?}, expected {:?}",
                    receiver,
                    fee_addr
                );
            }

            if value < expected_value {
                return ERR!("QRC20 Fee tx value {} is less than expected {}", value, expected_value);
            }

            let token_addr = try_s!(extract_token_addr_from_script(&script_pubkey));
            if token_addr != selfi.contract_address {
                return ERR!(
                    "QRC20 Fee tx {:?} called wrong smart contract, expected {:?}",
                    qtum_tx,
                    selfi.contract_address
                );
            }

            Ok(())
        };

        Box::new(fut.boxed().compat())
    }

    fn validate_maker_payment(
        &self,
        payment_tx: &[u8],
        time_lock: u32,
        maker_pub: &[u8],
        secret_hash: &[u8],
        amount: BigDecimal,
    ) -> Box<dyn Future<Item = (), Error = String> + Send> {
        let payment_tx: UtxoTx = try_fus!(deserialize(payment_tx).map_err(|e| ERRL!("{:?}", e)));
        let sender = try_fus!(self.qrc20_address_from_raw_pubkey(maker_pub));
        let secret_hash = secret_hash.to_vec();

        Box::new(
            qrc20_validate_payment(self.clone(), payment_tx, time_lock, sender, secret_hash, amount)
                .boxed()
                .compat(),
        )
    }

    fn validate_taker_payment(
        &self,
        payment_tx: &[u8],
        time_lock: u32,
        taker_pub: &[u8],
        secret_hash: &[u8],
        amount: BigDecimal,
    ) -> Box<dyn Future<Item = (), Error = String> + Send> {
        let payment_tx: UtxoTx = try_fus!(deserialize(payment_tx).map_err(|e| ERRL!("{:?}", e)));
        let sender = try_fus!(self.qrc20_address_from_raw_pubkey(taker_pub));
        let secret_hash = secret_hash.to_vec();

        Box::new(
            qrc20_validate_payment(self.clone(), payment_tx, time_lock, sender, secret_hash, amount)
                .boxed()
                .compat(),
        )
    }

    fn check_if_my_payment_sent(
        &self,
        time_lock: u32,
        _other_pub: &[u8],
        secret_hash: &[u8],
        search_from_block: u64,
    ) -> Box<dyn Future<Item = Option<TransactionEnum>, Error = String> + Send> {
        let selfi = self.clone();
        let expected_swap_id = qrc20_swap_id(time_lock, secret_hash);
        let my_address = qrc20_addr_from_utxo_addr(self.utxo_arc.my_address.clone());

        let fut = async move {
            let status = try_s!(selfi.payment_status(expected_swap_id.clone()).await);
            if status == PAYMENT_STATE_UNINITIALIZED.into() {
                return Ok(None);
            };

            let found = try_s!(
                selfi
                    .search_swap_tx_by_call_type_and_swap_id(
                        &ContractCallType::Erc20Payment,
                        &expected_swap_id,
                        &my_address,
                        search_from_block
                    )
                    .await
            );
            Ok(found.map(TransactionEnum::UtxoTx))
        };

        Box::new(fut.boxed().compat())
    }

    fn check_if_my_payment_completed(
        &self,
        payment_tx: &[u8],
        _time_lock: u32,
        _other_pub: &[u8],
        _secret_hash: &[u8],
    ) -> Box<dyn Future<Item = (), Error = String> + Send> {
        let payment_tx: UtxoTx = try_fus!(deserialize(payment_tx).map_err(|e| ERRL!("{:?}", e)));
        let selfi = self.clone();
        let fut = async move {
            let Erc20PaymentDetails { swap_id, .. } = try_s!(selfi.erc20_payment_details_from_tx(&payment_tx).await);

            let status = try_s!(selfi.payment_status(swap_id.clone()).await);
            if status != PAYMENT_STATE_SENT.into() {
                return ERR!("Payment state is not PAYMENT_STATE_SENT, got {}", status);
            }

            Ok(())
        };

        Box::new(fut.boxed().compat())
    }

    fn search_for_swap_tx_spend_my(
        &self,
        time_lock: u32,
        _other_pub: &[u8],
        secret_hash: &[u8],
        tx: &[u8],
        search_from_block: u64,
    ) -> Result<Option<FoundSwapTxSpend>, String> {
        let tx: UtxoTx = try_s!(deserialize(tx).map_err(|e| ERRL!("{:?}", e)));
        let fut = qrc20_search_for_swap_tx_spend(self.clone(), time_lock, secret_hash.to_vec(), tx, search_from_block);
        block_on(fut)
    }

    fn search_for_swap_tx_spend_other(
        &self,
        time_lock: u32,
        _other_pub: &[u8],
        secret_hash: &[u8],
        tx: &[u8],
        search_from_block: u64,
    ) -> Result<Option<FoundSwapTxSpend>, String> {
        let tx: UtxoTx = try_s!(deserialize(tx).map_err(|e| ERRL!("{:?}", e)));
        let fut = qrc20_search_for_swap_tx_spend(self.clone(), time_lock, secret_hash.to_vec(), tx, search_from_block);
        block_on(fut)
    }
}

impl MarketCoinOps for Qrc20Coin {
    fn ticker(&self) -> &str { &self.utxo_arc.ticker }

    fn my_address(&self) -> Result<String, String> { utxo_common::my_address(self) }

    fn my_balance(&self) -> Box<dyn Future<Item = BigDecimal, Error = String> + Send> {
        let my_address = qrc20_addr_from_utxo_addr(self.utxo_arc.my_address.clone());
        let selfi = self.clone();
        let fut = async move {
            let params = &[Token::Address(my_address)];
            let tokens = try_s!(selfi.rpc_contract_call(RpcContractCallType::BalanceOf, params).await);

            if tokens.is_empty() {
                return ERR!(r#"Expected Uint as "balanceOf" result but got nothing"#);
            }

            match tokens[0] {
                Token::Uint(bal) => u256_to_big_decimal(bal, selfi.utxo_arc.decimals),
                _ => ERR!(r#"Expected Uint as "balanceOf" result but got {:?}"#, tokens),
            }
        };

        Box::new(fut.boxed().compat())
    }

    fn base_coin_balance(&self) -> Box<dyn Future<Item = BigDecimal, Error = String> + Send> {
        // use standard UTXO my_balance implementation that returns Qtum balance instead of QRC20
        utxo_common::my_balance(&self.utxo_arc)
    }

    fn send_raw_tx(&self, tx: &str) -> Box<dyn Future<Item = String, Error = String> + Send> {
        utxo_common::send_raw_tx(&self.utxo_arc, tx)
    }

    fn wait_for_confirmations(
        &self,
        tx: &[u8],
        confirmations: u64,
        requires_nota: bool,
        wait_until: u64,
        check_every: u64,
    ) -> Box<dyn Future<Item = (), Error = String> + Send> {
        utxo_common::wait_for_confirmations(
            &self.utxo_arc,
            tx,
            confirmations,
            requires_nota,
            wait_until,
            check_every,
        )
    }

    fn wait_for_tx_spend(&self, transaction: &[u8], wait_until: u64, from_block: u64) -> TransactionFut {
        let selfi = self.clone();
        let tx: UtxoTx = try_fus!(deserialize(transaction).map_err(|e| ERRL!("{:?}", e)));
        let fut = async move {
            let Erc20PaymentDetails { swap_id, receiver, .. } = try_s!(selfi.erc20_payment_details_from_tx(&tx).await);
            loop {
                // Try to find a 'receiverSpend' contract call.
                // This means that we should request a transaction history for the possible spender of our payment - [`Erc20PaymentDetails::receiver`].
                let found = try_s!(
                    selfi
                        .search_swap_tx_by_call_type_and_swap_id(
                            &ContractCallType::ReceiverSpend,
                            &swap_id,
                            &receiver,
                            from_block,
                        )
                        .await
                );
                if let Some(spent_tx) = found {
                    return Ok(TransactionEnum::UtxoTx(spent_tx));
                }

                if now_ms() / 1000 > wait_until {
                    return ERR!(
                        "Waited too long until {} for transaction {:?} to be spent ",
                        wait_until,
                        tx
                    );
                }
                Timer::sleep(10.).await;
            }
        };
        Box::new(fut.boxed().compat())
    }

    fn tx_enum_from_bytes(&self, bytes: &[u8]) -> Result<TransactionEnum, String> {
        utxo_common::tx_enum_from_bytes(bytes)
    }

    fn current_block(&self) -> Box<dyn Future<Item = u64, Error = String> + Send> {
        utxo_common::current_block(&self.utxo_arc)
    }

    fn address_from_pubkey_str(&self, pubkey: &str) -> Result<String, String> {
        utxo_common::address_from_pubkey_str(self, pubkey)
    }

    fn display_priv_key(&self) -> String { utxo_common::display_priv_key(&self.utxo_arc) }
}

impl MmCoin for Qrc20Coin {
    fn is_asset_chain(&self) -> bool { utxo_common::is_asset_chain(&self.utxo_arc) }

    fn can_i_spend_other_payment(&self) -> Box<dyn Future<Item = (), Error = String> + Send> {
        let decimals = self.utxo_arc.decimals;
        Box::new(self.base_coin_balance().and_then(move |qtum_balance| {
            let sat_balance = try_s!(wei_from_big_decimal(&qtum_balance, decimals));
            let min_amount = QRC20_SWAP_GAS_REQUIRED * QRC20_GAS_PRICE_DEFAULT;
            log!("sat_balance " [sat_balance] " min_amount " [min_amount]);
            if sat_balance < min_amount.into() {
                return ERR!(
                    "Base coin balance {} is too low to cover gas fee, required {}",
                    qtum_balance,
                    big_decimal_from_sat(min_amount as i64, decimals),
                );
            }
            Ok(())
        }))
    }

    fn wallet_only(&self) -> bool { false }

    fn withdraw(&self, req: WithdrawRequest) -> Box<dyn Future<Item = TransactionDetails, Error = String> + Send> {
        Box::new(qrc20_withdraw(self.clone(), req).boxed().compat())
    }

    fn decimals(&self) -> u8 { utxo_common::decimals(&self.utxo_arc) }

    fn convert_to_address(&self, from: &str, to_address_format: Json) -> Result<String, String> {
        qtum::convert_qtum_address(&self.utxo_arc.ticker, from, to_address_format)
    }

    fn validate_address(&self, address: &str) -> ValidateAddressResult { utxo_common::validate_address(self, address) }

    fn process_history_loop(&self, ctx: MmArc) { utxo_common::process_history_loop(self, ctx) }

    fn tx_details_by_hash(&self, hash: &[u8]) -> Box<dyn Future<Item = TransactionDetails, Error = String> + Send> {
        let hash = H256Json::from(hash);
        Box::new(qrc20_tx_details_by_hash(self.clone(), hash).boxed().compat())
    }

    fn history_sync_status(&self) -> HistorySyncState { utxo_common::history_sync_status(&self.utxo_arc) }

    fn get_trade_fee(&self) -> Box<dyn Future<Item = TradeFee, Error = String> + Send> {
        utxo_common::get_trade_fee(self.clone())
    }

    fn required_confirmations(&self) -> u64 { utxo_common::required_confirmations(&self.utxo_arc) }

    fn requires_notarization(&self) -> bool { utxo_common::requires_notarization(&self.utxo_arc) }

    fn set_required_confirmations(&self, confirmations: u64) {
        utxo_common::set_required_confirmations(&self.utxo_arc, confirmations)
    }

    fn set_requires_notarization(&self, requires_nota: bool) {
        utxo_common::set_requires_notarization(&self.utxo_arc, requires_nota)
    }

    fn my_unspendable_balance(&self) -> Box<dyn Future<Item = BigDecimal, Error = String> + Send> {
        // QRC20 cannot have unspendable balance
        Box::new(futures01::future::ok(0.into()))
    }
}

pub fn qrc20_swap_id(time_lock: u32, secret_hash: &[u8]) -> Vec<u8> {
    let mut input = vec![];
    input.extend_from_slice(&time_lock.to_le_bytes());
    input.extend_from_slice(secret_hash);
    sha256(&input).to_vec()
}

pub fn qrc20_addr_from_str(address: &str) -> Result<H160, String> {
    // use deserialization instead of eth::contract_addr_from_str(),
    // because that function fails on some of the QRC20 contract addresses
    Ok(try_s!(json::from_str(&format!("\"{}\"", address))))
}

pub fn qrc20_addr_from_utxo_addr(address: Address) -> H160 { address.hash.take().into() }

fn utxo_addr_into_rpc_format(address: Address) -> H160Json { address.hash.take().into() }

fn qrc20_addr_into_rpc_format(address: &H160) -> H160Json { address.to_vec().as_slice().into() }

async fn qrc20_withdraw(coin: Qrc20Coin, req: WithdrawRequest) -> Result<TransactionDetails, String> {
    let to_addr = try_s!(Address::from_str(&req.to));
    let is_p2pkh =
        to_addr.prefix == coin.utxo_arc.pub_addr_prefix && to_addr.t_addr_prefix == coin.utxo_arc.pub_t_addr_prefix;
    let is_p2sh = to_addr.prefix == coin.utxo_arc.p2sh_addr_prefix
        && to_addr.t_addr_prefix == coin.utxo_arc.p2sh_t_addr_prefix
        && coin.utxo_arc.segwit;
    if !is_p2pkh && !is_p2sh {
        return ERR!("Address {} has invalid format", to_addr);
    }

    let _utxo_lock = UTXO_LOCK.lock().await;

    let qrc20_balance = try_s!(coin.my_balance().compat().await);

    // the qrc20_amount is used only within smart contract calls
    let qrc20_amount = if req.max {
        let amount = try_s!(wei_from_big_decimal(&qrc20_balance, coin.utxo_arc.decimals));
        if amount.is_zero() {
            return ERR!("Balance is 0");
        }
        amount
    } else {
        let amount = try_s!(wei_from_big_decimal(&req.amount, coin.utxo_arc.decimals));
        if amount.is_zero() {
            return ERR!("The amount {} is too small", req.amount);
        }

        // convert balance from big_decimal to U256 to compare it with the amount
        let balance = try_s!(wei_from_big_decimal(&qrc20_balance, coin.utxo_arc.decimals));
        if amount > balance {
            return ERR!(
                "The amount {} to withdraw is larger than balance {}",
                req.amount,
                qrc20_balance
            );
        }
        amount
    };

    let (gas_limit, gas_price) = match req.fee {
        Some(WithdrawFee::Qrc20Gas { gas_limit, gas_price }) => (gas_limit, gas_price),
        Some(_) => return ERR!("Unsupported input fee type"),
        None => (QRC20_GAS_LIMIT_DEFAULT, QRC20_GAS_PRICE_DEFAULT),
    };

    let transfer_output = try_s!(coin.transfer_output(
        qrc20_addr_from_utxo_addr(to_addr.clone()),
        qrc20_amount,
        gas_limit,
        gas_price
    ));
    let outputs = vec![transfer_output];

    let (signed, fee_details) = try_s!(coin.generate_qrc20_transaction(gas_limit, gas_price, outputs).await);

    let received_by_me = if to_addr == coin.utxo_arc.my_address {
        req.amount.clone()
    } else {
        0.into()
    };
    let my_balance_change = &received_by_me - &req.amount;
    let my_address = try_s!(coin.my_address());
    let to_address = try_s!(coin.display_address(&to_addr));
    Ok(TransactionDetails {
        from: vec![my_address],
        to: vec![to_address],
        total_amount: req.amount.clone(),
        spent_by_me: req.amount,
        received_by_me,
        my_balance_change,
        tx_hash: signed.hash().reversed().to_vec().into(),
        tx_hex: serialize(&signed).into(),
        fee_details: Some(fee_details.into()),
        block_height: 0,
        coin: coin.utxo_arc.ticker.clone(),
        internal_id: vec![].into(),
        timestamp: now_ms() / 1000,
    })
}

async fn qrc20_tx_details_by_hash(coin: Qrc20Coin, hash: H256Json) -> Result<TransactionDetails, String> {
    // TODO temporary
    Ok(try_s!(
        utxo_common::tx_details_by_hash(coin.clone(), &hash.0).compat().await
    ))

    // let mut receipts = match coin.as_ref().rpc_client {
    //     UtxoRpcClientEnum::Electrum(ref rpc) => try_s!(rpc.blochchain_transaction_get_receipt(&hash).compat().await),
    //     UtxoRpcClientEnum::Native(_) => return ERR!("Electrum client expected"),
    // };
    //
    // if receipts.len() != 1 {
    //     return ERR!(
    //         "blochchain.transaction.get_receipt returned {} receipts for {:?} transaction, expected 1",
    //         receipts.len(),
    //         hash
    //     );
    // }
    //
    // // receipt is one always
    // let receipt = receipts.remove(0);
    //
    // // request Qtum transaction details to get a tx_hex, timestamp, block_height and miner_fee
    // let qtum_tx = try_s!(utxo_common::tx_details_by_hash(coin.clone(), &hash.0).compat().await);
    // let script_pubkey: Script = {
    //     // Deserialize the UtxoTx to get a script pubkey
    //     let utxo_tx: UtxoTx = try_s!(deserialize(qtum_tx.tx_hex.as_slice()).map_err(|e| ERRL!("{:?}", e)));
    //     if utxo_tx.outputs.len() <= (receipt.output_index as usize) {
    //         return ERR!(
    //             "Length of the transaction {:?} outputs less than output_index {}",
    //             qtum_tx.tx_hash,
    //             receipt.output_index
    //         );
    //     }
    //
    //     utxo_tx.outputs[receipt.output_index as usize]
    //         .script_pubkey
    //         .clone()
    //         .into()
    // };
    //
    // // We can get a log_index from get_history call, but it is overhead to request it on every tx_details_by_hash(),
    // // because of this try to find corresponding log entry below
    // let log = match receipt.log.into_iter().find(|log_entry| {
    //     let contract_address = if log_entry.address.starts_with("0x") {
    //         log_entry.address.clone()
    //     } else {
    //         format!("0x{}", log_entry.address)
    //     };
    //     match qrc20_addr_from_str(&contract_address) {
    //         // contract address from the log entry should be equal to the coin's contract address
    //         Ok(addr) if addr == coin.contract_address => (),
    //         Ok(_) => return false,
    //         Err(e) => {
    //             log!("Error on parse " [contract_address] " contract address " [e]);
    //             return false;
    //         },
    //     }
    //
    //     // we find a log entry with three and more topics
    //     if log_entry.topics.len() < 3 {
    //         return false;
    //     }
    //     // the first topic should be ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
    //     // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2101
    //     log_entry.topics.first().unwrap() == QRC20_TRANSFER_TOPIC
    // }) {
    //     Some(log) => log,
    //     _ => return ERR!("Couldn't find a log entry that meets the requirements"),
    // };
    //
    // let amount = try_s!(U256::from_str(&log.data));
    // // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2111
    // let total_amount = try_s!(u256_to_big_decimal(amount, coin.decimals()));
    //
    // // log.topics[i < 3] is safe because of the checking above
    // // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2112
    // let from = try_s!(coin.address_from_log_topic(&log.topics[1]));
    // // https://github.com/qtumproject/qtum-electrum/blob/v4.0.2/electrum/wallet.py#L2113
    // let to = try_s!(coin.address_from_log_topic(&log.topics[2]));
    //
    // let spent_by_me = if from == coin.utxo_arc.my_address {
    //     total_amount.clone()
    // } else {
    //     0.into()
    // };
    // let received_by_me = if to == coin.utxo_arc.my_address {
    //     total_amount.clone()
    // } else {
    //     0.into()
    // };
    //
    // let from = vec![try_s!(coin.display_address(&from))];
    // let to = vec![try_s!(coin.display_address(&to))];
    //
    // let total_qtum_fee = match qtum_tx.fee_details {
    //     Some(TxFeeDetails::Utxo(UtxoFeeDetails { amount })) => amount,
    //     fee => return ERR!("Unexpected fee details {:?}", fee),
    // };
    //
    // let fee_details = {
    //     let gas_limit = try_s!(extract_gas_from_script(&script_pubkey, ExtractGasEnum::GasLimit));
    //     let gas_price = try_s!(extract_gas_from_script(&script_pubkey, ExtractGasEnum::GasPrice));
    //
    //     let total_gas_fee = utxo_common::big_decimal_from_sat(receipt.gas_used, coin.utxo_arc.decimals);
    //     Qrc20FeeDetails {
    //         // QRC20 fees are paid in base platform currency (in particular Qtum)
    //         coin: coin.platform.clone(),
    //         miner_fee: &total_qtum_fee - &total_gas_fee,
    //         gas_limit,
    //         gas_price,
    //         total_gas_fee,
    //     }
    // };
    //
    // // do not inherit the block_height from qtum_tx (usually it is None)
    // let block_height = receipt.block_number as u64;
    //
    // let my_balance_change = &received_by_me - &spent_by_me;
    // Ok(TransactionDetails {
    //     from,
    //     to,
    //     total_amount,
    //     spent_by_me,
    //     received_by_me,
    //     my_balance_change,
    //     block_height,
    //     fee_details: Some(fee_details.into()),
    //     internal_id: vec![].into(),
    //     ..qtum_tx
    // })
}

async fn qrc20_send_hash_time_locked_payment(
    coin: Qrc20Coin,
    id: Vec<u8>,
    value: U256,
    time_lock: u32,
    secret_hash: Vec<u8>,
    receiver_addr: H160,
) -> Result<TransactionEnum, String> {
    let allowance = try_s!(coin.allowance(coin.swap_contract_address).await);

    let mut outputs = Vec::default();
    // check if we should reset the allowance to 0 and raise this to the max available value (our balance)
    if allowance < value {
        let balance = try_s!(coin.my_balance().compat().await);
        let balance = try_s!(wei_from_big_decimal(&balance, coin.utxo_arc.decimals));
        if allowance > U256::zero() {
            // first reset the allowance to the 0
            outputs.push(try_s!(coin.approve_output(coin.swap_contract_address, 0.into())));
        }
        // set the allowance from 0 to `balance` after the previous output will be executed
        outputs.push(try_s!(coin.approve_output(coin.swap_contract_address, balance)));
    }

    // when this output is executed, the allowance will be sufficient allready
    outputs.push(try_s!(coin.erc20_payment_output(
        id,
        value,
        time_lock,
        &secret_hash,
        receiver_addr
    )));

    coin.send_contract_calls(outputs).await
}

async fn qrc20_spend_hash_time_locked_payment(
    coin: Qrc20Coin,
    payment_tx: UtxoTx,
    secret: Vec<u8>,
) -> Result<TransactionEnum, String> {
    let Erc20PaymentDetails {
        swap_id, value, sender, ..
    } = try_s!(coin.erc20_payment_details_from_tx(&payment_tx).await);

    let status = try_s!(coin.payment_status(swap_id.clone()).await);
    if status != PAYMENT_STATE_SENT.into() {
        return ERR!("Payment state is not PAYMENT_STATE_SENT, got {}", status);
    }

    let spend_output = try_s!(coin.receiver_spend_output(swap_id, value, secret, sender));
    coin.send_contract_calls(vec![spend_output]).await
}

async fn qrc20_refund_hash_time_locked_payment(coin: Qrc20Coin, payment_tx: UtxoTx) -> Result<TransactionEnum, String> {
    let Erc20PaymentDetails {
        swap_id,
        value,
        receiver,
        secret_hash,
        ..
    } = try_s!(coin.erc20_payment_details_from_tx(&payment_tx).await);

    let status = try_s!(coin.payment_status(swap_id.clone()).await);
    if status != PAYMENT_STATE_SENT.into() {
        return ERR!("Payment state is not PAYMENT_STATE_SENT, got {}", status);
    }

    let refund_output = try_s!(coin.sender_refund_output(swap_id, value, secret_hash, receiver));
    coin.send_contract_calls(vec![refund_output]).await
}

async fn qrc20_validate_payment(
    coin: Qrc20Coin,
    payment_tx: UtxoTx,
    time_lock: u32,
    sender: H160,
    secret_hash: Vec<u8>,
    amount: BigDecimal,
) -> Result<(), String> {
    let erc20_payment = try_s!(coin.erc20_payment_details_from_tx(&payment_tx).await);

    if sender != erc20_payment.sender {
        return ERR!("Payment tx was sent from wrong address, expected {:?}", sender);
    }

    // TODO refactor this to allow deploy new swap contracts
    if coin.swap_contract_address != erc20_payment.swap_contract_address {
        return ERR!(
            "Payment tx was sent to wrong address, expected {:?}",
            coin.swap_contract_address
        );
    }

    let expected_value = try_s!(wei_from_big_decimal(&amount, coin.utxo_arc.decimals));
    if expected_value != erc20_payment.value {
        return ERR!(
            "Invalid 'value' {:?} in swap payment, expected {:?}",
            erc20_payment.value,
            expected_value
        );
    }

    if coin.contract_address != erc20_payment.token_address {
        return ERR!(
            "Invalid 'token_address' {:?} in swap payment, expected {:?}",
            erc20_payment.token_address,
            coin.contract_address
        );
    }

    let expected_receiver = qrc20_addr_from_utxo_addr(coin.utxo_arc.my_address.clone());
    if expected_receiver != erc20_payment.receiver {
        return ERR!(
            "Invalid 'receiver' {:?} in swap payment, expected {:?}",
            erc20_payment.receiver,
            expected_receiver
        );
    }

    if secret_hash != erc20_payment.secret_hash {
        return ERR!(
            "Invalid 'secret_hash' {:?} in swap payment, expected {:?}",
            erc20_payment.secret_hash,
            secret_hash
        );
    }

    let expected_timelock = U256::from(time_lock);
    if expected_timelock != erc20_payment.timelock {
        return ERR!(
            "Invalid 'timelock' {:?} in swap payment, expected {:?}",
            erc20_payment.timelock,
            expected_timelock
        );
    }

    Ok(())
}

async fn qrc20_search_for_swap_tx_spend(
    coin: Qrc20Coin,
    time_lock: u32,
    secret_hash: Vec<u8>,
    tx: UtxoTx,
    search_from_block: u64,
) -> Result<Option<FoundSwapTxSpend>, String> {
    let electrum = match coin.utxo_arc.rpc_client {
        UtxoRpcClientEnum::Electrum(ref rpc_cln) => rpc_cln,

        UtxoRpcClientEnum::Native(_) => {
            return ERR!("Native mode not supported");
        },
    };

    let tx_hash = tx.hash().reversed().into();
    let verbose_tx = try_s!(electrum.get_verbose_transaction(tx_hash).compat().await);
    if verbose_tx.confirmations < 1 {
        return ERR!("'erc20Payment' was not confirmed yet. Please wait for at least one confirmation");
    }

    let Erc20PaymentDetails { swap_id, receiver, .. } = try_s!(coin.erc20_payment_details_from_tx(&tx).await);
    let expected_swap_id = qrc20_swap_id(time_lock, &secret_hash);
    if expected_swap_id != swap_id {
        return ERR!("Unexpected swap_id {}", hex::encode(swap_id));
    }

    // First try to find a 'receiverSpend' contract call.
    // This means that we should request a transaction history for the possible spender of our payment - [`Erc20PaymentDetails::receiver`].
    let found = try_s!(
        coin.search_swap_tx_by_call_type_and_swap_id(
            &ContractCallType::ReceiverSpend,
            &expected_swap_id,
            &receiver,
            search_from_block,
        )
        .await
    );
    if let Some(spent_tx) = found {
        return Ok(Some(FoundSwapTxSpend::Spent(TransactionEnum::UtxoTx(spent_tx))));
    }

    // Else try to find a 'senderRefund' contract call.
    // This means that we should request our transaction history because we could refund the payment already.
    let my_address = qrc20_addr_from_utxo_addr(coin.utxo_arc.my_address.clone());
    let found = try_s!(
        coin.search_swap_tx_by_call_type_and_swap_id(
            &ContractCallType::SenderRefund,
            &expected_swap_id,
            &my_address,
            search_from_block,
        )
        .await
    );
    if let Some(refunded_tx) = found {
        return Ok(Some(FoundSwapTxSpend::Refunded(TransactionEnum::UtxoTx(refunded_tx))));
    }

    Ok(None)
}

/// Serialize the `number` similar to BigEndian but in QRC20 specific format.
fn encode_contract_number(number: i64) -> Vec<u8> {
    // | encoded number (0 - 8 bytes) |
    // therefore the max result vector length is 8
    let capacity = 8;
    let mut encoded = Vec::with_capacity(capacity);

    if number == 0 {
        return Vec::new();
    }

    let is_negative = number.is_negative();
    let mut absnum = (number as i128).abs();

    while absnum != 0 {
        // absnum & 0xFF is first lowest byte
        encoded.push((absnum & 0xFF) as u8);
        absnum >>= 8;
    }

    if (encoded.last().unwrap() & 0x80) != 0 {
        encoded.push({
            if is_negative {
                0x80
            } else {
                0
            }
        });
    } else if is_negative {
        *encoded.last_mut().unwrap() |= 0x80;
    }

    encoded
}

fn decode_contract_number(source: &[u8]) -> Result<i64, String> {
    macro_rules! try_opt {
        ($e: expr) => {
            match $e {
                Some(x) => x,
                _ => return ERR!("Couldn't decode the input {:?}", source),
            }
        };
    }

    if source.is_empty() {
        return Ok(0);
    }

    let mut data = source.to_vec();

    // let last_byte = data.pop().unwrap();
    let mut decoded = 0i128;

    // first pop the data last byte
    let (is_negative, last_byte) = match data.pop().unwrap() {
        // this last byte is the sign byte, pop the real last byte
        0x80 => (true, try_opt!(data.pop())),
        // this last byte is the sign byte, pop the real last byte
        0 => (false, try_opt!(data.pop())),
        // this last byte is real, do XOR on it because it's greater than 0x80
        last_byte if 0x80 < last_byte => (true, last_byte ^ 0x80),
        // this last byte is real, returns it
        last_byte => (false, last_byte),
    };

    // push the last_byte back to the data array
    data.push(last_byte);

    for byte in data.iter().rev() {
        decoded <<= 8;
        decoded |= *byte as i128;
    }

    if is_negative {
        let decoded = decoded.neg();
        Ok(decoded as i64)
    } else {
        Ok(decoded as i64)
    }
}

/// Generate a script_pubkey contains a `function_call` from the specified `contract_address`.
/// The `contract_address` can be either Token address (QRC20) or Swap contract address (EtomicSwap).
fn generate_contract_call_script_pubkey(
    function_call: &[u8],
    gas_limit: u64,
    gas_price: u64,
    contract_address: &[u8],
) -> Result<Script, String> {
    if gas_limit == 0 || gas_price == 0 {
        // this is because the `contract_encode_number` will return an empty bytes
        return ERR!("gas_limit and gas_price cannot be zero");
    }

    if contract_address.is_empty() {
        // this is because the `push_bytes` will panic
        return ERR!("token_addr cannot be empty");
    }

    let gas_limit = encode_contract_number(gas_limit as i64);
    let gas_price = encode_contract_number(gas_price as i64);

    Ok(Builder::default()
        .push_opcode(Opcode::OP_4)
        .push_bytes(&gas_limit)
        .push_bytes(&gas_price)
        .push_data(function_call)
        .push_bytes(contract_address)
        .push_opcode(Opcode::OP_CALL)
        .into_script())
}

/// The `extract_gas_from_script_pubkey` helper.
#[derive(Clone, Copy, Debug)]
enum ExtractGasEnum {
    GasLimit = 1,
    GasPrice = 2,
}

/// Check if a given script contains a contract call.
/// First opcode should be OP_4 to be a contract call.
fn is_contract_call(script: &Script) -> bool {
    match script.iter().next() {
        Some(Ok(instr)) => instr.opcode == Opcode::OP_4,
        _ => false,
    }
}

fn extract_gas_from_script(script: &Script, extract: ExtractGasEnum) -> Result<u64, String> {
    let instruction = script
        .iter()
        .enumerate()
        .find_map(|(i, instr)| if i == extract as usize { Some(instr) } else { None })
        .ok_or(ERRL!("Couldn't extract {:?} from script pubkey", extract as usize))?
        .map_err(|e| ERRL!("Error on extract {:?} from pubkey: {}", extract, e))?;

    let opcode = instruction.opcode as usize;
    if !(1..75).contains(&opcode) {
        return ERR!("Opcode::OP_PUSHBYTES_[X] expected, found {:?}", instruction.opcode);
    }

    let number = match instruction.data {
        Some(d) => try_s!(decode_contract_number(d)),
        _ => return ERR!("Non-empty instruction data expected"),
    };

    Ok(number as u64)
}

fn extract_contract_call_from_script(script: &Script) -> Result<Vec<u8>, String> {
    const CONTRACT_CALL_IDX: usize = 3;
    let instruction = script
        .iter()
        .enumerate()
        .find_map(|(i, instr)| if i == CONTRACT_CALL_IDX { Some(instr) } else { None })
        .ok_or(ERRL!("Couldn't extract 'contract_params' from script pubkey"))?
        .map_err(|e| ERRL!("Error on extract 'contract_params' from pubkey: {}", e))?;

    match instruction.opcode {
        Opcode::OP_PUSHDATA1 | Opcode::OP_PUSHDATA2 | Opcode::OP_PUSHDATA4 => (),
        opcode if (1..75).contains(&(opcode as usize)) => (),
        _ => return ERR!("Unexpected instruction's opcode {}", instruction.opcode),
    }

    instruction
        .data
        .ok_or(ERRL!("An empty contract call data"))
        .map(Vec::from)
}

fn extract_token_addr_from_script(script: &Script) -> Result<H160, String> {
    const TOKEN_ADDRESS_IDX: usize = 4;
    let instruction = script
        .iter()
        .enumerate()
        .find_map(|(i, instr)| if i == TOKEN_ADDRESS_IDX { Some(instr) } else { None })
        .ok_or(ERRL!("Couldn't extract 'token_address' from script pubkey"))?
        .map_err(|e| ERRL!("Error on extract 'token_address' from pubkey: {}", e))?;

    match instruction.opcode {
        opcode if (1..75).contains(&(opcode as usize)) => (),
        _ => return ERR!("Unexpected instruction's opcode {}", instruction.opcode),
    }

    Ok(instruction.data.ok_or(ERRL!("An empty contract call data"))?.into())
}

#[cfg(test)]
mod qtum_tests {
    use super::*;
    use crate::{eth::u256_to_big_decimal, utxo::utxo_tests::electrum_client_for_test};
    use ethabi::Token;
    use keys::Address;

    #[test]
    fn blockchain_token_get_info() {
        let client = electrum_client_for_test(&["95.217.83.126:10001"]);
        let addr = hex::decode("d362e096e873eb7907e205fadc6175c6fec7bc44").unwrap();
        let expected_token_info = TokenInfo {
            name: "TEST".into(),
            decimals: 8,
            total_supply: 1000000000000000,
            symbol: "ARTEM".into(),
        };

        let actual_token_info = client
            .blockchain_token_get_info(&addr.as_slice().into())
            .wait()
            .unwrap();
        assert_eq!(expected_token_info, actual_token_info);
    }

    #[test]
    fn get_token_balance_using_contract_call() {
        let client = electrum_client_for_test(&["95.217.83.126:10001"]);
        let token_addr = hex::decode("d362e096e873eb7907e205fadc6175c6fec7bc44").unwrap();
        let our_addr: Address = "qKEDGuogDhtH9zBnc71QtqT1KDamaR1KJ3".parse().unwrap();
        log!((our_addr.prefix));
        let function = unwrap!(ERC20_CONTRACT.function("balanceOf"));
        let data = unwrap!(function.encode_input(&[Token::Address(our_addr.hash.take().into()),]));
        let balance = client
            .blockchain_contract_call(&token_addr.as_slice().into(), data.into())
            .wait()
            .unwrap();
        let tokens = function.decode_output(&balance.execution_result.output).unwrap();
        let balance = match tokens[0] {
            Token::Uint(bal) => bal,
            _ => panic!("Expected Uint, got {:?}", tokens[0]),
        };
        let balance = u256_to_big_decimal(balance, 8).unwrap();
        assert_eq!(balance, "139.00000".parse().unwrap());
    }

    #[test]
    fn test_encode_decode_contract_number() {
        let numbers = vec![
            // left is source number, right is expected encoded array
            (0i64, vec![]),
            (1, vec![1]),
            (-1, vec![129]),
            (40, vec![40]),
            (-40, vec![168]),
            (-127, vec![255]),
            (127, vec![127]),
            (-128, vec![128, 128]),
            (128, vec![128, 0]),
            (255, vec![255, 0]),
            (-255, vec![255, 128]),
            (256, vec![0, 1]),
            (-256, vec![0, 129]),
            (2500000, vec![160, 37, 38]),
            (-2500000, vec![160, 37, 166]),
            (i64::max_value(), vec![255, 255, 255, 255, 255, 255, 255, 127]),
            (i64::min_value(), vec![0, 0, 0, 0, 0, 0, 0, 128, 128]),
            (Opcode::OP_4 as i64, vec![84]),
            (Opcode::OP_CALL as i64, vec![194, 0]),
        ];

        for (source, encoded) in numbers {
            println!("{}", source);
            let actual_encoded = encode_contract_number(source);
            assert_eq!(actual_encoded, encoded);
            let actual_decoded = unwrap!(decode_contract_number(&encoded));
            assert_eq!(actual_decoded, source);
        }
    }

    #[test]
    fn test_extract_gas_limit_gas_price() {
        let script: Script = "5403a02526012844a9059cbb0000000000000000000000000240b898276ad2cc0d2fe6f527e8e31104e7fde3000000000000000000000000000000000000000000000000000000003b9aca0014d362e096e873eb7907e205fadc6175c6fec7bc44c2".into();

        let expected_gas_limit = 2_500_000;
        let actual = unwrap!(extract_gas_from_script(&script, ExtractGasEnum::GasLimit));
        assert_eq!(actual, expected_gas_limit);

        let expected_gas_price = 40;
        let actual = unwrap!(extract_gas_from_script(&script, ExtractGasEnum::GasPrice));
        assert_eq!(actual, expected_gas_price);
    }

    #[test]
    fn test_extract_contract_call() {
        let script: Script = "5403a02526012844a9059cbb0000000000000000000000000240b898276ad2cc0d2fe6f527e8e31104e7fde3000000000000000000000000000000000000000000000000000000003b9aca0014d362e096e873eb7907e205fadc6175c6fec7bc44c2".into();

        let to_addr: Address = "qHmJ3KA6ZAjR9wGjpFASn4gtUSeFAqdZgs".into();
        let to_addr = qrc20_addr_from_utxo_addr(to_addr);
        let amount: U256 = 1000000000.into();
        let function = ERC20_CONTRACT.function("transfer").unwrap();
        let expected = function
            .encode_input(&[Token::Address(to_addr), Token::Uint(amount)])
            .unwrap();

        let actual = unwrap!(extract_contract_call_from_script(&script));
        assert_eq!(actual, expected);

        // TX b11a262380657310abf01f8abe117da2c2adf788ab1fa0fa29da4ab505fc00c0
        let tx = unwrap!(hex::decode("01000000029ba0865fc62aac1f5f1a4aac3c9f54ff3d74211030bf6eb41e870b30297bd3fc010000006a47304402201808cbc98036ea63d32e858f776c722897d3f4b670744594deba25b69128d0ba02207b3f86f0ab6b6fa0ff581dc7be33af034c6004f3537a2f96c4ddf3ed0130defc012103693bff1b39e8b5a306810023c29b95397eb395530b106b1820ea235fd81d9ce9ffffffff63574ffa1e8edd8af8b08f3c1d8e5f33170772c38631a50ddc29c16d74c762f6020000006b483045022100db6cf963f6be56f7c6004ede74d452b2c5932eb6b12094fe67fa4ff0b6f4406e02207acff9163588a0c58fa009f5e876f90817b4006c303095d9b6425aae2922a485012103693bff1b39e8b5a306810023c29b95397eb395530b106b1820ea235fd81d9ce9ffffffff040000000000000000625403a08601012844095ea7b3000000000000000000000000ba8b71f3544b93e2f681f996da519a98ace0107a000000000000000000000000000000000000000000000000000000000000000014d362e096e873eb7907e205fadc6175c6fec7bc44c20000000000000000625403a08601012844095ea7b3000000000000000000000000ba8b71f3544b93e2f681f996da519a98ace0107a0000000000000000000000000000000000000000000000000000000001312d0014d362e096e873eb7907e205fadc6175c6fec7bc44c20000000000000000e35403a0860101284cc49b415b2a65e285b98480fd7de696e9fb5bcb68ec9468dd906c683e38cabb8f39905675fa0000000000000000000000000000000000000000000000000000000001312d00000000000000000000000000d362e096e873eb7907e205fadc6175c6fec7bc440000000000000000000000000240b898276ad2cc0d2fe6f527e8e31104e7fde30101010101010101010101010101010101010101000000000000000000000000000000000000000000000000000000000000000000000000000000005f6d80b814ba8b71f3544b93e2f681f996da519a98ace0107ac2e52fdd05000000001976a9149e032d4b0090a11dc40fe6c47601499a35d55fbb88ac82816d5f"));
        let utxo_tx: UtxoTx = unwrap!(deserialize(tx.as_slice()));

        // first output in "b11a262380657310abf01f8abe117da2c2adf788ab1fa0fa29da4ab505fc00c0"
        // `approve` to 0 contract call
        let expected = unwrap!(hex::decode("095ea7b3000000000000000000000000ba8b71f3544b93e2f681f996da519a98ace0107a0000000000000000000000000000000000000000000000000000000000000000"));
        let script = utxo_tx.outputs[0].script_pubkey.clone().into();

        let actual = unwrap!(extract_contract_call_from_script(&script));
        assert_eq!(actual, expected);

        // second output in "b11a262380657310abf01f8abe117da2c2adf788ab1fa0fa29da4ab505fc00c0"
        // `approve` to 20000000 contract call
        let expected = unwrap!(hex::decode("095ea7b3000000000000000000000000ba8b71f3544b93e2f681f996da519a98ace0107a0000000000000000000000000000000000000000000000000000000001312d00"));
        let script = utxo_tx.outputs[1].script_pubkey.clone().into();

        let actual = unwrap!(extract_contract_call_from_script(&script));
        assert_eq!(actual, expected);

        // third output in "b11a262380657310abf01f8abe117da2c2adf788ab1fa0fa29da4ab505fc00c0"
        // `erc20Payment` 20000000 amount contract call
        let expected = unwrap!(hex::decode("9b415b2a65e285b98480fd7de696e9fb5bcb68ec9468dd906c683e38cabb8f39905675fa0000000000000000000000000000000000000000000000000000000001312d00000000000000000000000000d362e096e873eb7907e205fadc6175c6fec7bc440000000000000000000000000240b898276ad2cc0d2fe6f527e8e31104e7fde30101010101010101010101010101010101010101000000000000000000000000000000000000000000000000000000000000000000000000000000005f6d80b8"));
        let script = utxo_tx.outputs[2].script_pubkey.clone().into();

        let actual = unwrap!(extract_contract_call_from_script(&script));
        assert_eq!(actual, expected);
    }

    #[test]
    fn extract_token_addr() {
        let script: Script = "5403a02526012844a9059cbb0000000000000000000000000240b898276ad2cc0d2fe6f527e8e31104e7fde3000000000000000000000000000000000000000000000000000000003b9aca0014d362e096e873eb7907e205fadc6175c6fec7bc44c2".into();
        let expected = qrc20_addr_from_str("0xd362e096e873eb7907e205fadc6175c6fec7bc44").unwrap();

        let actual = unwrap!(extract_token_addr_from_script(&script));
        assert_eq!(actual, expected);
    }
}
